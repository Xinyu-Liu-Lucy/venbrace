/**
 * File: ForgivingTokensVisitor.js 
 * Author: Lyn Turbak
 * Created: 2020/06/16-18
 * 
 * Generate an array of tokens from a VenbraceForgiving parse tree. 
 * 
 * Calling .visit on a program, test_program, or test_blocks parse tree returns
 * a list of tokens that includes inserted, deleted, and corrected tokens.
 * Also, optional tokens are marked optional. Here are the new properties on 
 * these tokens:
 * 
 *   + tok.inserted is true if tok is an inserted token (undefined otherwise). 
 *     Currently, the only inserted tokens are braces and 
 *     the MINUS token inserted when processing expr_block NEG_NUM. 
 * 
 *   + tok.deleted is true if tok is a deleted token (undefined otherwise)
 *      Currently, only brace tokens are deleted (when used around a suite). 
 * 
 *   + tok.corrected has the previous token text if tok has been corrected 
 *     (undefined otherwise). Currently, the only tokens corrected are 
 *     wrong-type braces and the NEG_NUM in expr_block NEG_NUM. 
 * 
 *   + tok.optional is true if tok is optional in the grammar (undefined otherwise).
 *     Inserted, deleted, and corrected tokens are never marked optional. 
 * 
 * In cases where expr NEG_NUM is converted to expr MINUS <positive version of NEG_NUM>,
 * the new MINUS token is marked as inserted and the <positive version of NEG_NUM>
 * token is marked as corrected. 
 * 
 * After .visit is called on a top-level program node, the following properties are
 * defined on the visitor: 
 * 
 *   + visitor.unfixedTokens is the unfixed list of tokens, in which tokens
 *       do not have correct tokenIndex, start, stop, line, and column information.
 *       In particular, inserted tokens have bogus information, and any tokens
 *       following an inserted token have incorrect information. 
 * 
 *   + visitor.tokens is the fixed list of tokens, in which all tokens have correct 
 *       tokenIndex, start, stop, line, and column information.
 *    
 *   + visitor.stringForTokens is a string that is consistent for the parsed tokens.
 *     I.e. the start/stop/line/column information for every tokens in visitor.tokens
 *     is consistent with this string. So this string can be used for the highlighting
 *     in the syntax editor using information on the tokens. 
 * 
 */

// inBrowser is defined in .html file. 
// If it's defined, then we're in the browser version.
// Otherwise, we're in the terminal version = node.js version. 
if ((typeof inBrowser) === 'undefined') {
  inBrowser = false;
}

var antlr4;

if (inBrowser) {
  antlr4 = require('./antlr4/index.js');
} else {
  antlr4 = require('antlr4');
}

var CommonToken = antlr4.CommonToken;
// [2020/06/17, lyn] None of these work. Why?
// var TerminalNodeImpl = antlr4.tree.TerminalNodeImpl;
// var TerminalNodeImpl = antlr4.Tree.TerminalNodeImpl;
// var TerminalNodeImpl = antlr4.TerminalNodeImpl;
// console.log('TerminalNodeImpl');
// console.log(TerminalNodeImpl);
var VenbraceForgivingVisitor = require('./VenbraceForgivingVisitor').VenbraceForgivingVisitor;
var Utils = require('./Utils');

// ---------- Set up inheritance ----------
function ForgivingTokensVisitor() {
  VenbraceForgivingVisitor.call(this);
}

ForgivingTokensVisitor.prototype = Object.create(VenbraceForgivingVisitor.prototype);
ForgivingTokensVisitor.prototype.constructor = ForgivingTokensVisitor;
// -----------------------------------------

// Visit a parse tree produced by #test_blocks.
ForgivingTokensVisitor.prototype.visitTest_blocks = function(ctx) {
  this.tokens = [] // Initialize token list that will be mutated 
                   // by each call to visitTerminal in tree walk by visitor. 
                   // After the walk, grab the tokens field from the listener. 
  this.visitChildren(ctx); // Walk the tree, ignoring the visitor return value. 
  this.unfixedTokens = this.tokens; // Rename tokens generated by visitor
  this.tokens = this.tokens.map( tok => tok.clone() ); // this.tokens now contains clones of visitor tokens. 
  // Mutate tokens in this.tokens to fix them, and generate consistent string for fixed tokens. 
  this.stringForTokens = fixupTokens(this.tokens)
  return this.tokens; // Return fixed tokens list at the end of the walk. 
}

// Visit a parse tree produced by #program
ForgivingTokensVisitor.prototype.visitProgram = function(ctx) {
  this.tokens = [] // Initialize token list that will be mutated 
                   // by each call to visitTerminal in tree walk by visitor. 
                   // After the walk, grab the tokens field from the listener. 
  this.visitChildren(ctx); // Walk the tree, ignoring the visitor return value. 
  this.unfixedTokens = this.tokens; // Rename tokens generated by visitor
  this.tokens = this.tokens.map( tok => tok.clone() ); // this.tokens now contains clones of visitor tokens. 
  // Mutate tokens in this.tokens to fix them, and generate consistent string for fixed tokens. 
  this.stringForTokens = fixupTokens(this.tokens)
  return this.tokens; // Return fixed tokens list at the end of the walk. 
}


// Visit a parse tree produced by #test_program.
ForgivingTokensVisitor.prototype.visitTest_program = function(ctx) {
  this.tokens = [] // Initialize token list that will be mutated 
                   // by each call to visitTerminal in tree walk by visitor. 
                   // After the walk, grab the tokens field from the listener. 
  this.visitChildren(ctx); // Walk the tree, ignoring the visitor return value. 
  this.unfixedTokens = this.tokens; // Rename tokens generated by visitor
  this.tokens = this.tokens.map( tok => tok.clone() ); // this.tokens now contains clones of visitor tokens. 
  // Mutate tokens in this.tokens to fix them, and generate consistent string for fixed tokens. 
  this.stringForTokens = fixupTokens(this.tokens)
  return this.tokens; // Return fixed tokens list at the end of the walk. 
}


// Special case for converting expr_block NEG_NUM to binary subtraction in cases like (a-17)
ForgivingTokensVisitor.prototype.visitImmutable_neg_num_special_case = function (ctx) {
  var negNumToken = ctx.NEG_NUM().getSymbol();
  var newMinusToken = negNumToken.clone(); 
  newMinusToken.type = 63; // hard-coded MINUS token type
  newMinusToken.stop = newMinusToken.start; // MINUS token is one character long
  newMinusToken.text = '-';
  newMinusToken.inserted = true;

  negNumToken.corrected = negNumToken.text;
  negNumToken.text = negNumToken.text.substring(1); // remove - sign
  negNumToken.type = 121; // NUMBER = 121, NEG_NUM = 122
  negNumToken.start = negNumToken.start + 1; // exclude - sign
  negNumToken.column = negNumToken.column + 1; // exclude - sign

  
  this.tokens.push(ctx.LPAREN().getSymbol()); 
  this.visit(ctx.expr_block()); // recursively process left operand expression
  this.tokens.push(newMinusToken);
  this.tokens.push(negNumToken);
  this.tokens.push(ctx.RPAREN().getSymbol()); 
}

ForgivingTokensVisitor.prototype.visitDecl_block = function(ctx) {
  /* 
     Allows zero or one left-brace tokens before stat and zero or one matching 
     right-brace tokens after stat. It will insert square brackets in no brace case 
     and convert nonsquares to squares. 
   */
  var lbraceToken = toToken(ctx.declLbrace);
  if (!lbraceToken) {
    // console.log('no declLbrace token'); 
    this.tokens.push(newLSQRToken()); // No left brace token; add LSQR
  } else {
    // console.log('declLbrace token: ' + lbraceToken.toString());
    this.tokens.push(ensureLSQR(lbraceToken));
  }
  this.visit(ctx.decl());
  var rbraceToken = toToken(ctx.declRbrace);
  if (!rbraceToken) {
    // console.log('no declLbrace token'); 
    this.tokens.push(newRSQRToken()); // No right brace token; add RSQR
  } else {
    // console.log('declRbrace token: ' + rbraceToken.toString());
    this.tokens.push(ensureRSQR(rbraceToken));
  }
}

ForgivingTokensVisitor.prototype.visitSuite = function(ctx) {
  /* 
     Allows zero or one left-brace tokens before stat suite zero or one matching 
     right-brace tokens after stat. The braces need not match. It will insert
     a curly in no brace case and convert noncurlies to curlies. 
   */
  // Collect all the child stat blocks
  // console.log('------------------------------------\nvisitSuite');
  var statBlockContexts = [];
  var i = 0;
  var statBlockContext = ctx.stat_block(i);
  while (statBlockContext) {
    statBlockContexts.push(statBlockContext);
    i += 1;
    statBlockContext = ctx.stat_block(i);
  }
  var emptyStatBlocks = statBlockContexts.length == 0;
  var lbraceToken = toToken(ctx.suiteLbrace);
  var rbraceToken = toToken(ctx.suiteRbrace);
  // console.log('num statBlocks: ' + statBlockContexts.length);
  // console.log('emptyStat=' + emptyStat);
  // console.log('lbraceToken:');
  // console.log(lbraceToken);
  // console.log('rbraceToken:');
  // console.log(rbraceToken);
  if (emptyStatBlocks && lbraceToken && rbraceToken) {
    // console.log('empty suite branch');
    // special case for explicit empty suite braces
    this.tokens.push(ensureLCURLY(lbraceToken));
    this.tokens.push(ensureRCURLY(rbraceToken));
  } else {
    // all other cases have no explicit suite braces
    if (lbraceToken) {
      // console.log('deleting lbrace branch');
      this.tokens.push(deletedToken(lbraceToken));
    }
    statBlockContexts.forEach( childCtx => this.visit(childCtx) ); 
    if (rbraceToken) {
      // console.log('deleting rbrace branch');
      this.tokens.push(deletedToken(rbraceToken));
    }
  }
}

ForgivingTokensVisitor.prototype.visitStat_block = function(ctx) {
  /* 
     Allows zero or one left-brace tokens before stat and zero or one matching 
     right-brace tokens after stat. It will insert a curly in no brace case and 
     convert noncurlies to curlies. 
   */
  var lbraceToken = toToken(ctx.statLbrace);
  if (!lbraceToken) {
    // console.log('no statLbrace token'); 
    this.tokens.push(newLCURLYToken()); // No left brace token; add LCURLY
  } else {
    // console.log('statLbrace token: ' + lbraceToken.toString());
    this.tokens.push(ensureLCURLY(lbraceToken));
  }
  this.visit(ctx.stat());
  var rbraceToken = toToken(ctx.statRbrace);
  if (!rbraceToken) {
    // console.log('no statLbrace token'); 
    this.tokens.push(newRCURLYToken()); // No right brace token; add RCURLY
  } else {
    // console.log('statRbrace token: ' + rbraceToken.toString());
    this.tokens.push(ensureRCURLY(rbraceToken));
  }
}

/* Automatic insertion of GLOBAL and LOCAL no longer supported.
   In practice, it does *not* work, because parser will 
   try to convert a LOCAL decl to a global decl ...

ForgivingTokensVisitor.prototype.visitGlobal_decl_keyword = function(ctx) {
  var terminalNode = ctx.GLOBAL();
  if (terminalNode) {
    this.tokens.push(terminalNode.getSymbol());
  } else {
    this.tokens.push(newGLOBALToken());
  }
}

ForgivingTokensVisitor.prototype.visitLocal_decl_keyword = function(ctx) {
  var terminalNode = ctx.LOCAL();
  if (terminalNode) {
    this.tokens.push(terminalNode.getSymbol());
  } else {
    this.tokens.push(newLOCALToken());
  }
}
*/

ForgivingTokensVisitor.prototype.visitTerminal = function(ctx) {
  // Default handler for terminal tokens not handled by explicit visitor
  var token = ctx.getSymbol(); // Returns the token at the terminal 
  var text = token.text;
  // console.log('visitTerminal ' + text);
  var parentNameWithContext = ctx.getParent().constructor.name;
  // if (isBrace(text)) {
  //   console.log('Brace token ' + text + ' with parent ' + parentNameWithContext);
  // 
  if (isOptional(ctx, token)) {
    token['optional'] = true;
  }
  this.tokens.push(token); // Add this token to end of visitor's tokens list
};

/* ***********************************************************
 * TOKEN HELPER FUNCTIONS
 * *********************************************************** 
 */

// Modify CommonToken toString method to handle 
// inserted, deleted, correct, and optional tokens
CommonToken.prototype.toString = function() {
  var txt = this.text;
  var correctedText = this.corrected;
  if (txt !== null) {
    txt = txt.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
  } else {
    txt = "<no text>";
  }
        return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" 
                + txt + "',<" + this.type + ">"
                + (this.channel > 0 ? ",channel=" + this.channel : "") + "," +
                + this.line + ":" + this.column 
                + (this.inserted ? ',inserted' : '')
                + (this.deleted ? ',deleted' : '')
                + (correctedText ? ',corrected:' + correctedText : '')
                + (this.optional ? ',optional' : '')
                + "]";
};

// Modify CommonToken clone method to handle 
// inserted, deleted, correct, and optional tokens
CommonToken.prototype.clone = function() {
  var t = new CommonToken(this.source, this.type, this.channel, this.start,
                          this.stop);
  t.tokenIndex = this.tokenIndex;
  t.line = this.line;
  t.column = this.column;
  t.text = this.text;
  if (this.inserted) { t.inserted = this.inserted; }
  if (this.deleted) { t.deleted = this.deleted; }
  if (this.corrected) { t.corrected = this.corrected; }
  if (this.optional) { t.optional = this.optional; }
  return t;
};

function isBrace(text) {
  return ['(', ')', '{', '}', '[',']'].includes(text);
}

function isOpenBrace(tok) {
  return ['(', '[', '{'].includes(tok.text);
}

function isOptional (ctx, token) {
  var parentNameWithContext = ctx.getParent().constructor.name;
  // console.log('Debug: ' + token + ' ' + parentNameWithContext);
  // Turn names like 'Decl_blockContext' into 'decl_block'
  var parentNameWithoutContext = parentNameWithContext.split('Context')[0].toLowerCase(); 
  optionalTexts = optionalTokens[parentNameWithoutContext]; 
  if (optionalTexts === undefined) {
    // not in dictionary
    return false;
  } else {
    return optionalTexts.includes(token.text);
  }
}

var optionalTokens = { // Dictionary for optional tokens
  'global_decl': ['to'], // Lyn sez `global` should *not* be optional
  'event_handler': ['do'], // What about params? 
  // Note for proc_decl: are 'do' and 'result' necessary for distinguishing noreturn and return cases?
  'procedure_do': ['do'], 
  'procedure_result': ['result'], 
  'for_each_from_to': ['from', 'to', 'by', 'do'], 
  'while': ['test', 'do'], 
  // Does *not* handle proc/method call labels as optional
  'setter': ['to'], 
  'local_var_decl_stat': ['to', 'in'], // Should 'local' be optional? Lyn sez NO!
  'getter': ['(', 'get', ')'], 
  'local_var_decl_expr': ['to', 'in'], // Should 'local' be optional? Lyn sez NO!
  'atom': ['(', ')']
  // Does *not* handle expression operation labels as optional
};

function ensureLSQR(token) {
  // Change left brace token to LSQR if not already '['; otherwise leave unchanged
  var text = token.text;
  if (text !== '[') {
    token.corrected = text;
    token.type = 6; // LSQR int in .tokens file
    token.text = '['; 
  }
  return token;
}

function ensureRSQR(token) {
  // Change left brace token to RSQR if not already ']'; otherwise leave unchanged
  var text = token.text;
  if (text !== ']') {
    token.corrected = text;
    token.type = 7; // RSQR int in .tokens file
    token.text = ']'; 
  }
  return token;
}

function newLSQRToken() {
  tok = new CommonToken(undefined, 6, // LSQR int in .tokens file
                        undefined, undefined, undefined);
  tok.text = '['; 
  // Don't fill out other properties (channel, start, stop, tokenIndex, line, column) yet
  tok.inserted = true;
  return tok; 
}

function newRSQRToken() {
  tok = new CommonToken(undefined, 7, // RSQR int in .tokens file
                        undefined, undefined, undefined);
  tok.text = ']'; 
  // Don't fill out other properties (channel, start, stop, tokenIndex, line, column) yet
  tok.inserted = true;
  return tok; 
}

function ensureLCURLY(token) {
  // Change left brace token to LCURLY if not already '['; otherwise leave unchanged
  var text = token.text;
  if (text !== '{') {
    token.corrected = text;
    token.type = 2; // LCURLY int in .tokens file
    token.text = '{'; 
  }
  return token;
}

function ensureRCURLY(token) {
  // Change left brace token to RCURLY if not already ']'; otherwise leave unchanged
  var text = token.text;
  if (text !== '}') {
    token.corrected = text;
    token.type = 3; // RCURLY int in .tokens file
    token.text = '}'; 
  }
  return token;
}

function newLCURLYToken() { // LCURLY int in .tokens file
  tok = new CommonToken(undefined, 2, undefined, undefined, undefined);
  tok.text = '{'; 
  // Don't fill out other properties (channel, start, stop, tokenIndex, line, column) yet
  tok.inserted = true;
  return tok; 
}

function newRCURLYToken() {
  tok = new CommonToken(undefined, 3, // RCURLY int in .tokens file
                        undefined, undefined, undefined);
  tok.text = '}'; 
  // Don't fill out other properties (channel, start, stop, tokenIndex, line, column) yet
  tok.inserted = true;
  return tok; 
}

function newGLOBALToken() {
  tok = new CommonToken(undefined, 27, // GLOBAL int in .tokens file
                        undefined, undefined, undefined);
  tok.text = 'global'; 
  // Don't fill out other properties (channel, start, stop, tokenIndex, line, column) yet
  tok.inserted = true;
  return tok; 
}

function newLOCALToken() {
  tok = new CommonToken(undefined, 30, // LOCAL int in .tokens file
                        undefined, undefined, undefined);
  tok.text = 'local'; 
  // Don't fill out other properties (channel, start, stop, tokenIndex, line, column) yet
  tok.inserted = true;
  return tok; 
}

function toToken(ctxOrToken) {
  // extract a token from ctxOrToken, or propagate null/undefined
  // Lyn sez Can't use instanceof with TerminalNodeImpl because I can't 
  // figure out how to import TerminalNodeImpl
  if (ctxOrToken == null) {
    return null;
  } 
  if (ctxOrToken == undefined) {
    return undefined;
  }
  var  className = getClassName(ctxOrToken);
  // console.log('toToken className: ' + className);
  if (className === "LbraceContext" || className === "RbraceContext") {
    return ctxOrToken.start;
  } else if (className === "TerminalNodeImpl") {
    return ctxOrToken.getSymbol();
  } else if (className === "CommonToken") {
    return ctxOrToken;
  } else {
    throw "can't convert object to a token";
  }
}

function deletedToken(token) {
  token.deleted = true;
  return token;
}

function getClassName(object) {
  return object.constructor.name;
}

// Fix token sequence with inserted tokens to have correct 
// tokenIndex, start, stop, line, and column numbers
// Perform fixes by mutating existing tokens. 
// Assume there is at least one regular (=noninserted) token
// Mutates tokens and returns a string that is consistent with being the 
// "source" input string for the fixed up tokens
function fixupTokens(tokens) {

  var resultString = ''; // New input string to match fixed up tokens
  var tokenIndex = 0;
  var charIndex = 0;
  var line = 0; // Lines start at 0, so this is smaller than first line
  var column = 0;
  var numSpaces = 0;

  var pendingInsertedOpenBraces = []; // Hold inserted open braces for later processing
                                      // They will come before next regular token,
                                      // and might be on next line rather than current one.
  var prevRegularTokenStop = undefined; 
  var prevRegularTokenLine = undefined; 

  function printState(msg, t) { // For debugging
    console.log(msg + tokenString(t)
                + "; token.text=" + t.text
                + "; tokenIndex=" + tokenIndex
                + "; charIndex=" + charIndex
                + "; line=" + line
                + "; column=" + column
                // + "; resultString:\n" + resultString
                );
  }

  function processToken(t) {
    // Update a token based on current state, and use token info to update state
    // printState("\nBefore processing ", t);
    var text = t.text;
    t.text = text; // IMPORTANT: This is required. Before this assignment to t.text,
                   // token uses start/stop to extract token from source.
                   // This assignment to token property caches the text string locally
                   // in the token itself for future references.
    t.tokenIndex = tokenIndex;
    tokenIndex++; // Increment token index for next token    
    t.line = line;
    t.column = column;
    t.start = charIndex;
    charIndex += text.length;
    t.stop = charIndex-1;
    column += text.length; // Update column for next token
    resultString += text; // Add token text to end of string
    // printState(" After processing ", t);
  }
  
  // Process all tokens, updating state values and token states. 
  tokens.forEach ( function (tok) {
      if (tok.tokenIndex != -1) {
        // This is a regular (noninserted) token
        if (!prevRegularTokenStop) {
          // This is the first regular token on first nonempty line
          charIndex = tok.start;
        } else {
          // Maintain space from prev regular token
          numSpaces = tok.start - (prevRegularTokenStop + 1); // space between tokens
          charIndex += numSpaces;
          column += numSpaces;
        }

        if (tok.line > line) {
          // First regular token on new line
          // Reset line, column, and charIndex
          line = tok.line;
          column = tok.column;
          if (tok.line == 1) {
            // On first line
            resultString += Utils.spaces(tok.column); // Insert spaces before first token
          } else {
            // For line other than first line, determine where newlines should go. 
            var leadingSpacesThisLine = Utils.spaces(tok.column); 
            var numNewlines = tok.line - prevRegularTokenLine;
            var trailingSpacesPrevLine = Utils.spaces(numSpaces - tok.column - numNewlines); 
            var newWhitespace = trailingSpacesPrevLine + Utils.newlines(numNewlines) + leadingSpacesThisLine; 
            // Invariant: newWhitespace.length == numSpaces
            resultString += newWhitespace
          }

        } else {
          resultString += Utils.spaces(numSpaces); // Add spaces before token. 
        }

        prevRegularTokenStop = tok.stop // remember for next time. 
        prevRegularTokenLine = tok.line // remember for next time. 

        // Process any pending open braces before the regular token
        // (these might be on a new line)
        pendingInsertedOpenBraces.forEach ( processToken );
        pendingInsertedOpenBraces = []; 
 
        // Process the regular token itself.
        processToken(tok);
      } else {
        // This is an inserted token (assumed a one-character brace, for now)
        if (isOpenBrace(tok)) {
          pendingInsertedOpenBraces.push(tok); // save for later processing before next regular token
        } else {
          processToken(tok); // process closed braces immediately (without any new space in front of them).
        }
      }
    });  
  // There shouldn't be any pending open braces at end,
  // but don't leave any tokens unprocessed:
  if (pendingInsertedOpenBraces.length > 0) {
    console.log('***WARNING; unexpected open braces at end of tokens: ' + pendingOpenBraces);
    pendingInsertedOpenBraces.forEach ( processToken );
    pendingInsertedOpenBraces = []; 
  }

  // Verify that start/stop info of mutated tokens matches result string
  tokens.forEach ( function (tok) {
      var textFromString = resultString.substring(tok.start, tok.stop+1);
      if (tok.text !== textFromString) {
        console.log("*** ParserTokenString verification failed for start/stop!");
        console.log("***       token text: '" + tok.text + "'");
        console.log("*** text from string: '" + textFromString + "'");
      } else {
        // console.log("ParserTokenString verification for start/stop suceeds at '" + tok.text + "'"); 
      }
    });

  // Verify that line/column info of mutated tokens matches result string
  lines = ['bogus 0th line'].concat(resultString.split('\n'));
  tokens.forEach ( function (tok) {
      var textFromLines = lines[tok.line].substring(tok.column, tok.column + (tok.stop + 1) - tok.start);
      if (tok.text !== textFromLines) {
        console.log("*** ParserTokenString verification failed for line/column!");
        console.log("***     token text: '" + tok.text + "'");
        console.log("*** text from lines: '" + textFromLines + "'");
      } else {
        // console.log("ParserTokenString verification for line/column suceeds at '" + tok.text + "'"); 
      }
    });

  return resultString; // Return the string matching the mutated tokens
}

exports.ForgivingTokensVisitor = ForgivingTokensVisitor;





